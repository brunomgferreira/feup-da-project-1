<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Water Supply Analysis System: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Water Supply Analysis System
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">FEUP - DA Project 1</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Graph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class representing a graph.  
 <a href="class_graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa0ece00411674a2d73696555cf494daf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa0ece00411674a2d73696555cf494daf">copyGraph</a> ()</td></tr>
<tr class="memdesc:aa0ece00411674a2d73696555cf494daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of the graph.  <a href="class_graph.html#aa0ece00411674a2d73696555cf494daf">More...</a><br /></td></tr>
<tr class="separator:aa0ece00411674a2d73696555cf494daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4522e8e26a13194b45365b33694925"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph_metrics.html">GraphMetrics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a5f4522e8e26a13194b45365b33694925">calculateMetrics</a> (const unordered_map&lt; string, <a class="el" href="class_delivery_site.html">DeliverySite</a> * &gt; *deliverySites)</td></tr>
<tr class="memdesc:a5f4522e8e26a13194b45365b33694925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates various metrics for the graph based on delivery site flow data.  <a href="class_graph.html#a5f4522e8e26a13194b45365b33694925">More...</a><br /></td></tr>
<tr class="separator:a5f4522e8e26a13194b45365b33694925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de64474940d70519941928f8367b643"><td class="memItemLeft" align="right" valign="top">pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a0de64474940d70519941928f8367b643">getTotalDemandAndMaxFlow</a> (const unordered_map&lt; string, <a class="el" href="class_delivery_site.html">DeliverySite</a> * &gt; *deliverySites) const</td></tr>
<tr class="memdesc:a0de64474940d70519941928f8367b643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the total demand and maximum flow in the graph.  <a href="class_graph.html#a0de64474940d70519941928f8367b643">More...</a><br /></td></tr>
<tr class="separator:a0de64474940d70519941928f8367b643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2090db526062a84a9cfb25073685cf"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a9c2090db526062a84a9cfb25073685cf">getMainSourceCode</a> ()</td></tr>
<tr class="memdesc:a9c2090db526062a84a9cfb25073685cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the code of the main source vertex in the graph.  <a href="class_graph.html#a9c2090db526062a84a9cfb25073685cf">More...</a><br /></td></tr>
<tr class="separator:a9c2090db526062a84a9cfb25073685cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c74724f79cd6306afa588e0bd113cd"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a42c74724f79cd6306afa588e0bd113cd">getMainTargetCode</a> ()</td></tr>
<tr class="memdesc:a42c74724f79cd6306afa588e0bd113cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the code of the main target vertex in the graph.  <a href="class_graph.html#a42c74724f79cd6306afa588e0bd113cd">More...</a><br /></td></tr>
<tr class="separator:a42c74724f79cd6306afa588e0bd113cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d08c48629578407e852d2d8dcadbbd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a6d08c48629578407e852d2d8dcadbbd4">findVertex</a> (const string &amp;code) const</td></tr>
<tr class="memdesc:a6d08c48629578407e852d2d8dcadbbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a vertex in the graph based on its code.  <a href="class_graph.html#a6d08c48629578407e852d2d8dcadbbd4">More...</a><br /></td></tr>
<tr class="separator:a6d08c48629578407e852d2d8dcadbbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd653d89f9fbddcbab4a9ba1b70dcc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a2cd653d89f9fbddcbab4a9ba1b70dcc7">addVertex</a> (const string &amp;code, const VertexType &amp;type)</td></tr>
<tr class="memdesc:a2cd653d89f9fbddcbab4a9ba1b70dcc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex to the graph.  <a href="class_graph.html#a2cd653d89f9fbddcbab4a9ba1b70dcc7">More...</a><br /></td></tr>
<tr class="separator:a2cd653d89f9fbddcbab4a9ba1b70dcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8479c5a64f0b007960e8621a3c7660c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab8479c5a64f0b007960e8621a3c7660c">addEdge</a> (const string &amp;source, const string &amp;dest, double c, double f=0) const</td></tr>
<tr class="memdesc:ab8479c5a64f0b007960e8621a3c7660c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge between two vertices in the graph.  <a href="class_graph.html#ab8479c5a64f0b007960e8621a3c7660c">More...</a><br /></td></tr>
<tr class="separator:ab8479c5a64f0b007960e8621a3c7660c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96da6414041b1a856bdff1a9e6abdb76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a96da6414041b1a856bdff1a9e6abdb76">addBidirectionalEdge</a> (const string &amp;source, const string &amp;dest, double c, double flow=0, double reverseFlow=0) const</td></tr>
<tr class="memdesc:a96da6414041b1a856bdff1a9e6abdb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bidirectional edge between two vertices in the graph.  <a href="class_graph.html#a96da6414041b1a856bdff1a9e6abdb76">More...</a><br /></td></tr>
<tr class="separator:a96da6414041b1a856bdff1a9e6abdb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c6157baf3250a0780c7a9a34ffde7c"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; string, <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af7c6157baf3250a0780c7a9a34ffde7c">getVertexSet</a> () const</td></tr>
<tr class="memdesc:af7c6157baf3250a0780c7a9a34ffde7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the set of vertices in the graph.  <a href="class_graph.html#af7c6157baf3250a0780c7a9a34ffde7c">More...</a><br /></td></tr>
<tr class="separator:af7c6157baf3250a0780c7a9a34ffde7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe593ef28d5fed82f4e6118d53473b15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#abe593ef28d5fed82f4e6118d53473b15">setAllEdgesFlow</a> (double f)</td></tr>
<tr class="memdesc:abe593ef28d5fed82f4e6118d53473b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the flow value of all edges in the graph to a specified value.  <a href="class_graph.html#abe593ef28d5fed82f4e6118d53473b15">More...</a><br /></td></tr>
<tr class="separator:abe593ef28d5fed82f4e6118d53473b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5f0d564741c6541d1f0db43df676f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a2e5f0d564741c6541d1f0db43df676f2">setAllVerticesFlow</a> (double f)</td></tr>
<tr class="memdesc:a2e5f0d564741c6541d1f0db43df676f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the flow value of all vertices in the graph to a specified value.  <a href="class_graph.html#a2e5f0d564741c6541d1f0db43df676f2">More...</a><br /></td></tr>
<tr class="separator:a2e5f0d564741c6541d1f0db43df676f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffc84f05075b2492edc7c581bd8e883"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a9ffc84f05075b2492edc7c581bd8e883">updateAllVerticesFlow</a> ()</td></tr>
<tr class="memdesc:a9ffc84f05075b2492edc7c581bd8e883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the flow values of all vertices in the graph.  <a href="class_graph.html#a9ffc84f05075b2492edc7c581bd8e883">More...</a><br /></td></tr>
<tr class="separator:a9ffc84f05075b2492edc7c581bd8e883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b0af4f1a7f170decfdbdaa110d434b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a45b0af4f1a7f170decfdbdaa110d434b">createMainSource</a> (const unordered_map&lt; string, <a class="el" href="class_water_reservoir.html">WaterReservoir</a> * &gt; *waterReservoirs)</td></tr>
<tr class="memdesc:a45b0af4f1a7f170decfdbdaa110d434b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the main source vertex and connects it to water reservoirs.  <a href="class_graph.html#a45b0af4f1a7f170decfdbdaa110d434b">More...</a><br /></td></tr>
<tr class="separator:a45b0af4f1a7f170decfdbdaa110d434b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6858292fa146e19caba11f538530893d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a6858292fa146e19caba11f538530893d">createMainTarget</a> (const unordered_map&lt; string, <a class="el" href="class_delivery_site.html">DeliverySite</a> * &gt; *deliverySites)</td></tr>
<tr class="memdesc:a6858292fa146e19caba11f538530893d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the main target vertex and connects it to delivery sites.  <a href="class_graph.html#a6858292fa146e19caba11f538530893d">More...</a><br /></td></tr>
<tr class="separator:a6858292fa146e19caba11f538530893d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f8981fc2b4d9b9c802e2c5a4d2c8d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa9f8981fc2b4d9b9c802e2c5a4d2c8d0">maxFlow</a> (const unordered_map&lt; string, <a class="el" href="class_water_reservoir.html">WaterReservoir</a> * &gt; *waterReservoirs, const unordered_map&lt; string, <a class="el" href="class_delivery_site.html">DeliverySite</a> * &gt; *deliverySites)</td></tr>
<tr class="memdesc:aa9f8981fc2b4d9b9c802e2c5a4d2c8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum flow in the graph using the Edmonds-Karp algorithm.  <a href="class_graph.html#aa9f8981fc2b4d9b9c802e2c5a4d2c8d0">More...</a><br /></td></tr>
<tr class="separator:aa9f8981fc2b4d9b9c802e2c5a4d2c8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488e6f0af66b7961d836fbdfcd775477"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a488e6f0af66b7961d836fbdfcd775477">optimizeLoad</a> (const unordered_map&lt; string, <a class="el" href="class_delivery_site.html">DeliverySite</a> * &gt; *deliverySites)</td></tr>
<tr class="memdesc:a488e6f0af66b7961d836fbdfcd775477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizes the load distribution in the graph to improve flow characteristics.  <a href="class_graph.html#a488e6f0af66b7961d836fbdfcd775477">More...</a><br /></td></tr>
<tr class="separator:a488e6f0af66b7961d836fbdfcd775477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e1f6937bba59a7222dadfbbed5c8d6"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a91e1f6937bba59a7222dadfbbed5c8d6">getPaths</a> (const string &amp;source, const string &amp;dest)</td></tr>
<tr class="memdesc:a91e1f6937bba59a7222dadfbbed5c8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all paths from a source vertex to a destination vertex in the graph.  <a href="class_graph.html#a91e1f6937bba59a7222dadfbbed5c8d6">More...</a><br /></td></tr>
<tr class="separator:a91e1f6937bba59a7222dadfbbed5c8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936c7892f6bbef325d2151dfe0309d2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a936c7892f6bbef325d2151dfe0309d2e">dfs</a> (const string &amp;current, const string &amp;dest, vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &amp;path, vector&lt; vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt;&gt; &amp;paths)</td></tr>
<tr class="memdesc:a936c7892f6bbef325d2151dfe0309d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs depth-first search (DFS) to find paths from a source vertex to a destination vertex in the graph.  <a href="class_graph.html#a936c7892f6bbef325d2151dfe0309d2e">More...</a><br /></td></tr>
<tr class="separator:a936c7892f6bbef325d2151dfe0309d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5b77141277fd38c0ff0a1b1be2eb33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3f5b77141277fd38c0ff0a1b1be2eb33">stationOutOfCommission</a> (string const *code)</td></tr>
<tr class="memdesc:a3f5b77141277fd38c0ff0a1b1be2eb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a pumping station or reservoir as out of commission and adjusts the flow in the graph.  <a href="class_graph.html#a3f5b77141277fd38c0ff0a1b1be2eb33">More...</a><br /></td></tr>
<tr class="separator:a3f5b77141277fd38c0ff0a1b1be2eb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb025c5c980901d2be35503cb3ea6726"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#adb025c5c980901d2be35503cb3ea6726">pipelineOutOfCommission</a> (string const *servicePointA, string const *servicePointB, bool unidirectional)</td></tr>
<tr class="memdesc:adb025c5c980901d2be35503cb3ea6726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a pipeline between two service points as out of commission and adjusts the flow in the graph.  <a href="class_graph.html#adb025c5c980901d2be35503cb3ea6726">More...</a><br /></td></tr>
<tr class="separator:adb025c5c980901d2be35503cb3ea6726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e6637316cccc7ea45ea52b86a2814d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a20e6637316cccc7ea45ea52b86a2814d">deactivateVertex</a> (<a class="el" href="class_vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:a20e6637316cccc7ea45ea52b86a2814d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivates a vertex and adjusts the flow in the graph.  <a href="class_graph.html#a20e6637316cccc7ea45ea52b86a2814d">More...</a><br /></td></tr>
<tr class="separator:a20e6637316cccc7ea45ea52b86a2814d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead61bcc1a44b6440713b34c9a6cff99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aead61bcc1a44b6440713b34c9a6cff99">detectAndDeactivateFlowCycles</a> (<a class="el" href="class_vertex.html">Vertex</a> *deactivatedVertex)</td></tr>
<tr class="memdesc:aead61bcc1a44b6440713b34c9a6cff99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects and deactivates flow cycles originating from a specified vertex.  <a href="class_graph.html#aead61bcc1a44b6440713b34c9a6cff99">More...</a><br /></td></tr>
<tr class="separator:aead61bcc1a44b6440713b34c9a6cff99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c082a4fb3f273b26cfb1ee520e0dfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa4c082a4fb3f273b26cfb1ee520e0dfb">findAndDeactivateFlowPath</a> (<a class="el" href="class_vertex.html">Vertex</a> *deactivatedVertex)</td></tr>
<tr class="memdesc:aa4c082a4fb3f273b26cfb1ee520e0dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and deactivates a flow path originating from a specified vertex.  <a href="class_graph.html#aa4c082a4fb3f273b26cfb1ee520e0dfb">More...</a><br /></td></tr>
<tr class="separator:aa4c082a4fb3f273b26cfb1ee520e0dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a790c8dc16a2e1f3e5ae05d2a3ff4f03f"><td class="memItemLeft" align="right" valign="top"><a id="a790c8dc16a2e1f3e5ae05d2a3ff4f03f"></a>
unordered_map&lt; string, <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertices</b></td></tr>
<tr class="separator:a790c8dc16a2e1f3e5ae05d2a3ff4f03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89054f2bcbd89b5b69bebbd4bf427329"><td class="memItemLeft" align="right" valign="top"><a id="a89054f2bcbd89b5b69bebbd4bf427329"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>mainSourceCode</b> = &quot;mainSource&quot;</td></tr>
<tr class="separator:a89054f2bcbd89b5b69bebbd4bf427329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4520514c9213a22c622e6c51c7a071"><td class="memItemLeft" align="right" valign="top"><a id="aae4520514c9213a22c622e6c51c7a071"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>mainTargetCode</b> = &quot;mainTarget&quot;</td></tr>
<tr class="separator:aae4520514c9213a22c622e6c51c7a071"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class representing a graph. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a96da6414041b1a856bdff1a9e6abdb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96da6414041b1a856bdff1a9e6abdb76">&#9670;&nbsp;</a></span>addBidirectionalEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addBidirectionalEdge </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>flow</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>reverseFlow</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a bidirectional edge between two vertices in the graph. </p>
<p>This function adds a bidirectional edge between the vertices with the given source and destination codes. If either of the vertices does not exist in the graph, the function returns false, indicating that the edge could not be added. Otherwise, it creates two edges: one from source to dest and another from dest to source, each with the specified capacity and flow. Additionally, it sets the reverse pointers for the edges to maintain bidirectionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The code of the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>The code of the destination vertex. </td></tr>
    <tr><td class="paramname">c</td><td>The capacity of the edge. </td></tr>
    <tr><td class="paramname">flow</td><td>The flow through the edge from source to dest. </td></tr>
    <tr><td class="paramname">reverseFlow</td><td>The flow through the reverse edge from dest to source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the bidirectional edge is successfully added, false otherwise.</dd></dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the time complexity of finding vertices in the graph, adding edges to the vertices, and setting reverse pointers, all of which are O(1) in the worst case. </p>

</div>
</div>
<a id="ab8479c5a64f0b007960e8621a3c7660c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8479c5a64f0b007960e8621a3c7660c">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an edge between two vertices in the graph. </p>
<p>This function adds an edge from the vertex with the source code to the vertex with the destination code. If either of the vertices does not exist in the graph, the function returns false, indicating that the edge could not be added. Otherwise, it adds the edge to the origin vertex and checks if there is a corresponding reverse edge in the destination vertex. If a reverse edge exists and has the same capacity as the newly added edge, it sets the reverse pointers for both edges to maintain bidirectionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The code of the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>The code of the destination vertex. </td></tr>
    <tr><td class="paramname">c</td><td>The capacity of the edge. </td></tr>
    <tr><td class="paramname">f</td><td>The flow through the edge from source to dest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the edge is successfully added, false otherwise.</dd></dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the time complexity of finding vertices in the graph, adding edges to the vertices, and setting reverse pointers, all of which are O(1) in the worst case. </p>

</div>
</div>
<a id="a2cd653d89f9fbddcbab4a9ba1b70dcc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd653d89f9fbddcbab4a9ba1b70dcc7">&#9670;&nbsp;</a></span>addVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addVertex </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexType &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vertex to the graph. </p>
<p>This function adds a vertex with the given code and type to the graph. If a vertex with the same code already exists in the graph, the function returns false, indicating that the vertex could not be added. Otherwise, it creates a new vertex, inserts it into the graph's vertex set, and returns true to indicate a successful addition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>The code of the vertex to be added. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the vertex to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the vertex is successfully added, false otherwise.</dd></dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the time complexity of finding a vertex in the graph, which is O(1) in the worst case, and inserting a new vertex into the vertex set, which is also O(1) in the worst case. </p>

</div>
</div>
<a id="a5f4522e8e26a13194b45365b33694925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4522e8e26a13194b45365b33694925">&#9670;&nbsp;</a></span>calculateMetrics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph_metrics.html">GraphMetrics</a> Graph::calculateMetrics </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; string, <a class="el" href="class_delivery_site.html">DeliverySite</a> * &gt; *&#160;</td>
          <td class="paramname"><em>deliverySites</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates various metrics for the graph based on delivery site flow data. </p>
<p>This function calculates absolute and relative metrics for the graph based on the flow values of the delivery sites. Absolute metrics include average absolute difference, absolute variance, absolute standard deviation, and maximum absolute difference. Relative metrics include average relative difference, relative variance, relative standard deviation, and maximum relative difference. It also determines the maximum flow and total demand in the graph. The calculated metrics are encapsulated in a <a class="el" href="class_graph_metrics.html" title="Class to save the metrics of a given graph.">GraphMetrics</a> object and returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deliverySites</td><td>A pointer to an unordered map containing delivery site objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_metrics.html" title="Class to save the metrics of a given graph.">GraphMetrics</a> object containing various metrics calculated for the graph.</dd></dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the number of edges in the graph. Let, E be the total number of edges. The worst-case time complexity is O(V + E) due to the nested loops iterating over vertices and edges. </p>

</div>
</div>
<a id="aa0ece00411674a2d73696555cf494daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ece00411674a2d73696555cf494daf">&#9670;&nbsp;</a></span>copyGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> * Graph::copyGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a deep copy of the graph. </p>
<p>This function creates a new graph that is an exact copy of the original graph, including all vertices and edges. It iterates over all vertices in the original graph, copies them, and adds them to the new graph. Then, it iterates over all edges in the original graph, copies them along with their attributes, and adds them to the new graph. After copying, it updates the flow of all vertices in the new graph to match the original graph. Finally, it returns a pointer to the newly created graph.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created copy of the graph.</dd></dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the number of vertices and edges in the original graph. Let V be the number of vertices and E be the number of edges in the original graph. The worst-case time complexity is O(E + V) due to the two loops iterating over vertices and edges, respectively. Additionally, updating the flow of vertices has a time complexity of O(V). </p>

</div>
</div>
<a id="a45b0af4f1a7f170decfdbdaa110d434b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b0af4f1a7f170decfdbdaa110d434b">&#9670;&nbsp;</a></span>createMainSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::createMainSource </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; string, <a class="el" href="class_water_reservoir.html">WaterReservoir</a> * &gt; *&#160;</td>
          <td class="paramname"><em>waterReservoirs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the main source vertex and connects it to water reservoirs. </p>
<p>This function creates the main source vertex in the graph and connects it to each water reservoir with an edge representing the maximum delivery capacity of the reservoir. It iterates through the water reservoirs provided in the unordered map and adds an edge from the main source vertex to each water reservoir, with the capacity equal to the maximum delivery capacity of the reservoir and the current flow in the corresponding edge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waterReservoirs</td><td>A pointer to the unordered map containing water reservoir data.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the number of water reservoirs in the input unordered map. If there are n water reservoirs, the time complexity is O(n). </p>

</div>
</div>
<a id="a6858292fa146e19caba11f538530893d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6858292fa146e19caba11f538530893d">&#9670;&nbsp;</a></span>createMainTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::createMainTarget </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; string, <a class="el" href="class_delivery_site.html">DeliverySite</a> * &gt; *&#160;</td>
          <td class="paramname"><em>deliverySites</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the main target vertex and connects it to delivery sites. </p>
<p>This function creates the main target vertex in the graph and connects it to each delivery site with an edge representing the demand of the delivery site. It iterates through the delivery sites provided in the unordered map and adds an edge from each delivery site to the main target vertex, with the capacity equal to the demand of the delivery site and the current flow in the corresponding edge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deliverySites</td><td>A pointer to the unordered map containing delivery site data.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the number of delivery sites in the input unordered map. If there are n delivery sites, the time complexity is O(n). </p>

</div>
</div>
<a id="a20e6637316cccc7ea45ea52b86a2814d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e6637316cccc7ea45ea52b86a2814d">&#9670;&nbsp;</a></span>deactivateVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::deactivateVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deactivates a vertex and adjusts the flow in the graph. </p>
<p>This function deactivates a vertex and adjusts the flow in the graph. It iteratively checks for flow cycles involving the deactivated vertex and deactivates them by reducing the flow along the cycle. If no flow cycles are detected, it finds and deactivates flow paths originating from the deactivated vertex. This process continues until the deactivated vertex has no more flow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deactivatedVertex</td><td>The vertex to deactivate.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the size and structure of the graph, as well as the number of flow cycles and flow paths involving the deactivated vertex. In the worst case, where the deactivated vertex has flow connected to all other vertices in the graph, and there are many flow cycles and paths, the function's time complexity can be O(V * (E^2)), where V is the number of vertices and E is the number of edges. However, in practice, it often performs efficiently since it terminates once the deactivated vertex has no more flow. </p>

</div>
</div>
<a id="aead61bcc1a44b6440713b34c9a6cff99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead61bcc1a44b6440713b34c9a6cff99">&#9670;&nbsp;</a></span>detectAndDeactivateFlowCycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::detectAndDeactivateFlowCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>deactivatedVertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detects and deactivates flow cycles originating from a specified vertex. </p>
<p>This function detects and deactivates flow cycles in the graph originating from the specified vertex. It performs a breadth-first search (BFS) starting from the deactivated vertex to identify cycles with positive flow. If a cycle is found, it deactivates the flow along the cycle by updating the flow values of the edges. The function returns true if a cycle is detected and deactivated; otherwise, it returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deactivatedVertex</td><td>The vertex from which to start detecting flow cycles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a flow cycle is detected and deactivated, false otherwise.</dd></dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the size of the graph and the presence of flow cycles. In the worst case, where there are flow cycles originating from the deactivated vertex, the function performs a BFS traversal, which has a time complexity of O(V + E), where V is the number of vertices and E is the number of edges in the graph. Additionally, the function updates flow values along the cycle, which adds additional time complexity proportional to the number of edges in the cycle. </p>

</div>
</div>
<a id="a936c7892f6bbef325d2151dfe0309d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936c7892f6bbef325d2151dfe0309d2e">&#9670;&nbsp;</a></span>dfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::dfs </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs depth-first search (DFS) to find paths from a source vertex to a destination vertex in the graph. </p>
<p>This function recursively performs depth-first search (DFS) starting from the current vertex to find paths from a source vertex to a destination vertex in the graph. It marks visited vertices to avoid infinite loops and maintains a vector of edges representing the current path being explored. If the destination vertex is reached, the current path is added to the vector of paths. Otherwise, it continues exploring adjacent vertices that have available capacity for flow. This function is used to find all possible paths from a source to a destination in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>The code of the current vertex being visited. </td></tr>
    <tr><td class="paramname">dest</td><td>The code of the destination vertex. </td></tr>
    <tr><td class="paramname">path</td><td>The vector of edges representing the current path being explored. </td></tr>
    <tr><td class="paramname">paths</td><td>The vector of vectors of edges representing all found paths from the source to the destination.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; A DFS has a time complexity of O(V+E). Where V is the number of vertices and E is the number of edges. </p>

</div>
</div>
<a id="aa4c082a4fb3f273b26cfb1ee520e0dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c082a4fb3f273b26cfb1ee520e0dfb">&#9670;&nbsp;</a></span>findAndDeactivateFlowPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::findAndDeactivateFlowPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>deactivatedVertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds and deactivates a flow path originating from a specified vertex. </p>
<p>This function finds and deactivates a flow path in the graph originating from the specified vertex. It first performs a BFS traversal from the deactivated vertex to find a path to the main target vertex. Then, it performs another BFS traversal from the main source vertex to the deactivated vertex. Finally, it identifies the common path between the two traversals and deactivates the flow along this path. The function updates the flow values of the edges along the path to reduce the flow. If no path is found or the path has no positive flow, no action is taken.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deactivatedVertex</td><td>The vertex from which to start searching for a flow path.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the size of the graph and the length of the flow path from the deactivated vertex to the main target vertex. In the worst case, where the flow path covers the entire graph, the function performs two BFS traversals, each with a time complexity of O(V + E), where V is the number of vertices and E is the number of edges in the graph. Additionally, the function updates flow values along the identified path, which adds additional time complexity proportional to the number of edges in the path. </p>

</div>
</div>
<a id="a6d08c48629578407e852d2d8dcadbbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d08c48629578407e852d2d8dcadbbd4">&#9670;&nbsp;</a></span>findVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vertex.html">Vertex</a> * Graph::findVertex </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a vertex in the graph based on its code. </p>
<p>This function searches for a vertex with the given code in the graph's vertex set. If the vertex is found, a pointer to it is returned; otherwise, nullptr is returned to indicate that the vertex could not be found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>The code of the vertex to be found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the vertex if found, nullptr otherwise.</dd></dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the time complexity of finding an element in an unordered_map, which is O(1) in the worst case. </p>

</div>
</div>
<a id="a9c2090db526062a84a9cfb25073685cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2090db526062a84a9cfb25073685cf">&#9670;&nbsp;</a></span>getMainSourceCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Graph::getMainSourceCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the code of the main source vertex in the graph. </p>
<p>This function returns the code of the main source vertex, which is a specific vertex used in flow algorithms such as max flow.</p>
<dl class="section return"><dt>Returns</dt><dd>The code of the main source vertex.</dd></dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; This function has a time complexity of O(1) as it performs a simple retrieval operation. </p>

</div>
</div>
<a id="a42c74724f79cd6306afa588e0bd113cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c74724f79cd6306afa588e0bd113cd">&#9670;&nbsp;</a></span>getMainTargetCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Graph::getMainTargetCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the code of the main target vertex in the graph. </p>
<p>This function returns the code of the main target vertex, which is a specific vertex used in flow algorithms such as max flow.</p>
<dl class="section return"><dt>Returns</dt><dd>The code of the main target vertex.</dd></dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; This function has a time complexity of O(1) as it performs a simple retrieval operation. </p>

</div>
</div>
<a id="a91e1f6937bba59a7222dadfbbed5c8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e1f6937bba59a7222dadfbbed5c8d6">&#9670;&nbsp;</a></span>getPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt; Graph::getPaths </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all paths from a source vertex to a destination vertex in the graph. </p>
<p>This function finds all paths from a given source vertex to a destination vertex in the graph. It initializes a vector of vectors of edges to store the paths found. Then, it initializes an empty vector representing the current path and marks all vertices as unvisited. Next, it invokes the depth-first search (DFS) algorithm to explore paths from the source to the destination. Finally, it returns the vector of paths found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The code of the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>The code of the destination vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors of edges representing all paths from the source to the destination.</dd></dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the size and structure of the graph, as well as the number of paths found. It calls the DFS function, which has a time complexity of O(V + E), where V is the number of vertices and E is the number of edges. Therefore, the overall time complexity is also O(V + E) in the worst case. However, in practice, it often performs efficiently, especially if the graph is sparse or there are a limited number of paths from the source to the destination. </p>

</div>
</div>
<a id="a0de64474940d70519941928f8367b643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de64474940d70519941928f8367b643">&#9670;&nbsp;</a></span>getTotalDemandAndMaxFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; double, double &gt; Graph::getTotalDemandAndMaxFlow </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; string, <a class="el" href="class_delivery_site.html">DeliverySite</a> * &gt; *&#160;</td>
          <td class="paramname"><em>deliverySites</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the total demand and maximum flow in the graph. </p>
<p>This function iterates over all delivery sites in the provided unordered map and calculates the total demand and maximum flow in the graph based on the flow values of the delivery sites. It sums up the demand of each delivery site to calculate the total demand and adds the flow of each delivery site to calculate the maximum flow. It returns a pair containing the total demand and maximum flow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deliverySites</td><td>A pointer to an unordered map containing delivery site objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing the total demand and maximum flow in the graph.</dd></dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the number of delivery sites in the provided unordered map. In the worst case, it iterates over all delivery sites once, resulting in a time complexity of O(n), where n is the number of delivery sites. </p>

</div>
</div>
<a id="af7c6157baf3250a0780c7a9a34ffde7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c6157baf3250a0780c7a9a34ffde7c">&#9670;&nbsp;</a></span>getVertexSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; string, <a class="el" href="class_vertex.html">Vertex</a> * &gt; Graph::getVertexSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the set of vertices in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>An unordered map containing the vertices of the graph, where the keys are vertex codes and the values are pointers to the corresponding vertices.</dd></dl>
<p>This function returns a copy of the unordered map containing all vertices in the graph. It does not modify the original graph.</p>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; O(1) </p>

</div>
</div>
<a id="aa9f8981fc2b4d9b9c802e2c5a4d2c8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f8981fc2b4d9b9c802e2c5a4d2c8d0">&#9670;&nbsp;</a></span>maxFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::maxFlow </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; string, <a class="el" href="class_water_reservoir.html">WaterReservoir</a> * &gt; *&#160;</td>
          <td class="paramname"><em>waterReservoirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; string, <a class="el" href="class_delivery_site.html">DeliverySite</a> * &gt; *&#160;</td>
          <td class="paramname"><em>deliverySites</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum flow in the graph using the Edmonds-Karp algorithm. </p>
<p>This function computes the maximum flow in the graph using the Edmonds-Karp algorithm. It first creates the main source and main target vertices based on the provided water reservoirs and delivery sites. Then, it initializes the flow of all edges and vertices to zero. Finally, it applies the Edmonds-Karp algorithm to compute the maximum flow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waterReservoirs</td><td>A pointer to the unordered map containing water reservoir data. </td></tr>
    <tr><td class="paramname">deliverySites</td><td>A pointer to the unordered map containing delivery site data.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the implementation of the Edmonds-Karp algorithm, which has a worst-case time complexity of O(V * E^2), where V is the number of vertices and E is the number of edges in the graph. </p>

</div>
</div>
<a id="a488e6f0af66b7961d836fbdfcd775477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488e6f0af66b7961d836fbdfcd775477">&#9670;&nbsp;</a></span>optimizeLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::optimizeLoad </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; string, <a class="el" href="class_delivery_site.html">DeliverySite</a> * &gt; *&#160;</td>
          <td class="paramname"><em>deliverySites</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimizes the load distribution in the graph to improve flow characteristics. </p>
<p>This function optimizes the load distribution in the graph to improve flow characteristics. It calculates the initial metrics of the graph using the provided delivery sites, initializes the final metrics to be the same as the initial metrics, and retrieves all edges in the graph. Then, it iteratively performs load optimization until convergence criteria are met or the maximum number of iterations is reached. In each iteration, it sorts the edges based on the difference between capacity and flow, and then for each edge, it finds paths between its source and destination vertices. It selects the path with the maximum minimum residual capacity and adjusts the flow along the path accordingly. After each iteration, it updates the final metrics and checks for convergence. The optimization process continues until convergence criteria are met or the maximum number of iterations is reached. Finally, it updates the flow values of all vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deliverySites</td><td>Pointer to the unordered map containing delivery sites information.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the number of edges in the graph, the number of delivery sites, and the efficiency of the path-finding algorithm. Let V be the number of vertices and E be the number of edges. The worst-case time complexity is O(n(E * (V + E))), where n is the number of iterations. </p>

</div>
</div>
<a id="adb025c5c980901d2be35503cb3ea6726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb025c5c980901d2be35503cb3ea6726">&#9670;&nbsp;</a></span>pipelineOutOfCommission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::pipelineOutOfCommission </td>
          <td>(</td>
          <td class="paramtype">string const *&#160;</td>
          <td class="paramname"><em>servicePointA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string const *&#160;</td>
          <td class="paramname"><em>servicePointB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unidirectional</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks a pipeline between two service points as out of commission and adjusts the flow in the graph. </p>
<p>This function marks a pipeline between two service points as out of commission by deactivating the corresponding vertices and and adjusts the flow in the graph. Then, it deactivates the vertex corresponding to the origin service point. If the pipeline is bidirectional, it also deactivates the vertex corresponding to the destination service point. After deactivating the vertices, it recalculates the maximum flow in the graph using the Edmonds-Karp algorithm with the deactivated edges. Finally, it updates the flow values of all vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">servicePointA</td><td>Pointer to the code of the first service point. </td></tr>
    <tr><td class="paramname">servicePointB</td><td>Pointer to the code of the second service point. </td></tr>
    <tr><td class="paramname">unidirectional</td><td>Indicates whether the pipeline is unidirectional (true) or bidirectional (false).</td></tr>
  </table>
  </dd>
</dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the size and structure of the graph, as well as the efficiency of the Edmonds-Karp algorithm. In the worst case, where the graph is dense and the Edmonds-Karp algorithm has to run multiple times, the time complexity can be O(V * (E^2)), where V is the number of vertices and E is the number of edges. However, in practice, it performs efficiently, because it does not execute the Edmonds-Karp from the beginning. </p>

</div>
</div>
<a id="abe593ef28d5fed82f4e6118d53473b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe593ef28d5fed82f4e6118d53473b15">&#9670;&nbsp;</a></span>setAllEdgesFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::setAllEdgesFlow </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the flow value of all edges in the graph to a specified value. </p>
<p>This function iterates through all vertices in the graph and for each vertex, it iterates through its adjacent edges. It then sets the flow value of each edge to the specified value 'f' by calling the setFlow() function of the <a class="el" href="class_edge.html" title="Class representing an edge in a graph.">Edge</a> class for each edge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The flow value to set for all edges.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the number of vertices and edges in the graph. Let V be the number of vertices and E be the number of edges. The worst-case time complexity is O(V + E), as it iterates through all vertices and edges once to set the flow value of each edge. </p>

</div>
</div>
<a id="a2e5f0d564741c6541d1f0db43df676f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5f0d564741c6541d1f0db43df676f2">&#9670;&nbsp;</a></span>setAllVerticesFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::setAllVerticesFlow </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the flow value of all vertices in the graph to a specified value. </p>
<p>This function iterates through all vertices in the graph and sets the flow value of each vertex to the specified value 'f' by calling the setFlow() function of the <a class="el" href="class_vertex.html" title="Represents a vertex in the graph, corresponding to a WaterReservoir, or a PumpingStation,...">Vertex</a> class for each vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The flow value to set for all vertices.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the number of vertices in the graph. Let V be the number of vertices. The time complexity is O(V), as it iterates through all vertices once and sets the flow value of each vertex. </p>

</div>
</div>
<a id="a3f5b77141277fd38c0ff0a1b1be2eb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5b77141277fd38c0ff0a1b1be2eb33">&#9670;&nbsp;</a></span>stationOutOfCommission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::stationOutOfCommission </td>
          <td>(</td>
          <td class="paramtype">string const *&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks a pumping station or reservoir as out of commission and adjusts the flow in the graph. </p>
<p>This function marks a pumping station or reservoir as out of commission by deactivating the corresponding vertex and adjusts the flow in the graph. It first runs the Edmonds-Karp algorithm to find the maximum flow in the graph. Then, it deactivates the vertex corresponding to the provided code. After deactivating the vertex, it recalculates the maximum flow in the graph using the Edmonds-Karp algorithm with the deactivated vertex. Finally, it updates the flow values of all vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>Pointer to the code of the pumping station or reservoir to be deactivated.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the size and structure of the graph, as well as the efficiency of the Edmonds-Karp algorithm. In the worst case, where the graph is dense and the Edmonds-Karp algorithm has to run multiple times, the time complexity can be O(V * (E^2)), where V is the number of vertices and E is the number of edges. However, in practice, it performs efficiently, because it does not execute the Edmonds-Karp from the beginning. </p>

</div>
</div>
<a id="a9ffc84f05075b2492edc7c581bd8e883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ffc84f05075b2492edc7c581bd8e883">&#9670;&nbsp;</a></span>updateAllVerticesFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::updateAllVerticesFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the flow values of all vertices in the graph. </p>
<p>This function iterates through all vertices in the graph and updates the flow value of each vertex by calling the updateFlow() function of the <a class="el" href="class_vertex.html" title="Represents a vertex in the graph, corresponding to a WaterReservoir, or a PumpingStation,...">Vertex</a> class for each vertex.</p>
<p><b>Time Complexity:</b><br  />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; The time complexity of this function depends on the number of vertices in the graph. Let V be the number of vertices. The time complexity is O(V), as it iterates through all vertices once and updates the flow value of each vertex. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>Graph.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
